<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="ja" lang="ja">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta http-equiv="Cache-Control" content="no-cache"> 
<meta http-equiv="Content-Script-Type" content="text/javascript">
<meta http-equiv="Content-Style-Type" content="text/css">
<meta name="keywords" content="PHP,フレームワーク,MVC,軽量">
<meta name="description" content="軽量でシンプルなPHPのMVCフレームワーク">
<link rel="stylesheet" type="text/css" href="/css/jquery-ui/jquery-ui.css" />
<link rel="stylesheet" type="text/css" href="/css/layout.css" />
<link rel="stylesheet" type="text/css" href="/css/common.css" />
<link rel="stylesheet" type="text/css" href="/css/manual.css" />
<script type="text/javascript" src="/js/jquery.js"></script>
<script type="text/javascript" src="/js/jquery-ui.js"></script>
<script type="text/javascript" src="/js/common.js"></script>
<title>軽量シンプルPHPフレームワーク | Curry</title>
</head>
<body>

<div id="header_frame">
  <div id="header_frame_inner">

    <div class="clear"></div>
    <h1 class="logo">Curry<br /><span>PHP Framework</span></h1>
    <ul id="main_menu">
          <li><a href="/reference">リファレンス</a></li>
          <li class="selected"><a href="/manual">マニュアル</a></li>
          <li><a href="/index">ホーム</a></li>
        </ul>
    <div class="clear"></div>
  </div>
</div>


<div id="main_frame">



  <div id="left_frame">

  <ul id="side_menu">
            <li class="selected"><a href="/manual/about">Curryの特徴</a></li>
                <li><a href="/manual/introduction">導入</a></li>
                <li><a href="/manual/url">URL</a></li>
                <li><a href="/manual/dirs">ディレクトリ構成</a></li>
                <li><a href="/manual/naming">名前規則</a></li>
                <li><a href="/manual/init">初期設定</a></li>
                <li><a href="/manual/controller">コントローラー</a></li>
                <li><a href="/manual/validate">バリデーション</a></li>
                <li><a href="/manual/error">エラー制御</a></li>
                <li><a href="/manual/model">モデル</a></li>
                <li><a href="/manual/data">データアクセス</a></li>
                <li><a href="/manual/view">ビュー</a></li>
                <li><a href="/manual/viewscript">ビュースクリプト</a></li>
                <li><a href="/manual/service">サービス</a></li>
                <li><a href="/manual/config">設定ファイル</a></li>
                <li><a href="/manual/customize">カスタマイズ</a></li>
                <li><a href="/manual/pager">ページング処理</a></li>
                <li><a href="/manual/log">ログ出力</a></li>
                <li><a href="/manual/rest">REST</a></li>
                <li><a href="/manual/html">HTML自動生成</a></li>
                <li><a href="/manual/form">フォーム自動生成</a></li>
          </ul>
  </div>
  
  <div id="right_frame">
    <h2>Curryの特徴</h2>  
    <ul id="title_list">
                  <li><a href="#2">MVCアーキテクチャ</a></li>
                        <li><a href="#4">軽量・シンプル</a></li>
                        <li><a href="#3">規約と設定のバランス</a></li>
                        <li><a href="#5">モデルの自由度</a></li>
                        <li><a href="#7">O/Rマッパーの功罪とCurryでの位置付け</a></li>
                        <li><a href="#6">4層アーキテクチャ</a></li>
                        <li><a href="#8">RESTへの対応</a></li>
              </ul>

	      <h3 id="2">MVCアーキテクチャ</h3>
    		<p class="exp">
CurryはMVCアーキテクチャを基本としています。<br />
Mはモデルを指し、システムを構築する上での事象を具現化した概念です。具体的にはメインロジックとデータを表します。<br />
Vはビューを指し、ユーザーインターフェイスに関わる処理を受け持つ概念です。具体的にはHTMLの生成を行います。<br />
Cはコントローラーを指し、クライアントからのリクエストを直接処理し、モデルやビューを制御します。<br />
<br />
Curryではコントローラーがリクエストを受け、その情報をもとにモデルに処理を依頼し、コントローラーはその結果を受け取り、ビューにその結果を渡し、それをもとにビューがHTMLを生成する。という流れが基本となります。<br />
コントローラーがモデルとビューの間に立ち、仲介をする役割を担うわけです。<br />
また、クライアントよりのリクエストやセッションを直接操作するのはコントローラーのみで、モデルやビューはコントローラーよりその情報をパラメーターとして受け取って処理を行います。モデルやビューは直接リクエスト情報は参照しません。<br />
<br />
本来のMVCはビューとモデルの間に直接のやり取りが発生します。<br />
しかしCurryではビューにロジックが少しでも入り込む危険性のある手法を避けるため、上記のような概念を基本としています。<br />
これは逆にコントローラーにロジックが入り込む危険性を生むことにもなるため、実装上は注意が必要なのも事実です。
</p>
				
	      <h3 id="4">軽量・シンプル</h3>
    		<p class="exp">
有力なフレームワークは基本となる処理部分が膨らんでおり、処理の軽快さに欠ける欠点があります。あらゆる場面に対応するため、機能を詰め込んでいるためです。<br />
しかし多くの場合はそのような多彩な機能を必要としません。<br />
<br />
Curryではリクエストからユーザーロジックへ到達するまでの処理を必要最小限に削ぎ、軽量化しています。<br />
またWebでは必須と言えるデータベースアクセスの部分も処理を単純化し、処理コストを極力抑えています。<br />
<br />
フレームワークを利用する場合でも、フレームワークのソースを追いかける必要のある場面は発生しがちです。<br />
Curryでは可読性を意識してソースの記述を極力シンプルにしているため、解析のしやすさも一つの強みです。そのため、フレームワーク自体のカスタマイズもしやすくなっています。
</p>
				
	      <h3 id="3">規約と設定のバランス</h3>
    		<p class="exp">
フレームワークの使い勝手を左右する要素として、規約と設定が存在します。<br />
Ruby on Railsの流れを汲む、CakePHPような規約を重視したフレームワークの場合、規約に従ったコーディングにより、迷いもなく、スムーズな開発が可能です。しかしこれは柔軟性に欠けるという弊害もあります。また大規模なシステムには対応がしにくいということもあります。<br />
逆にZendFrameworkのような、規約に乏しいフレームワークの場合、ある程度実装者が考えてコーディングを行う必要があり、コーディング量も増え、開発速度は少し遅くなりがちですが、柔軟性に富み、実装者のコーディングスタイルに合わせたコーディングが出来、大規模なシステムにも対応しやすいメリットがあります。<br />
<br />
フレームワークの柔軟性を高める要素として、設定を利用する方法があります。<br />
設定ファイルやクラスの設定などを利用し、あらゆるコーディングスタイルに対応するという手法です。<br />
<br />
Curryは開発効率と柔軟性の両立を目指し、またそのバランスをユーザーで決めることができるように設計しています。<br />
基本は規則に従ったコーディングを行うことで開発効率を重視しています。<br />
が、設定ファイルやクラスであらゆる設定が可能になっており、柔軟性も確保しています。<br />
各種命名規則やディレクトリ構成まで設定で変えられるようになっています。
</p>
				
	      <h3 id="5">モデルの自由度</h3>
    		<p class="exp">
MVCにおいてモデルはメインロジックを担当するというのは動かない思想です。<br />
しかし、メインロジックと一言に言っても幅が広く、モデルの設計が多様であることも事実です。逆に言えばモデルの設計は自由度が高く、その良し悪しがシステムの良し悪しに直結すると言っても過言ではありません。<br />
フレームワークによってはモデルの実装も規約に則らなければならいようになっているものもあります。典型的なのはRuby on Railsで、モデルクラスはテーブルと１対１に結び付けられており、モデルクラス同士でリレーションを設定するような仕組みで、まさにテーブルを直接操作する感覚でモデルを利用します。<br />
<br />
個々のモデルの設計の考え方としてはいくつかが考えられますが、一つは上記のRailsのような、モデルクラス=テーブルのような考え方です。データベースの物理的なテーブルと結び付けられており、モデル同士でリレーションを表す形となります。このような設計は一般的にO/Rマッパーとよばれています。<br />
<br />
次に、テーブル単位のクラスではなく、事象の論理的単位にモデルクラスを設計する考え方です。リレーショナルデータベースは複数のテーブルのリレーションにより、論理的なオブジェクトの概念を構成するような性質のものです。そこでモデルクラスをその論理的な単位で作成し、それに関連する処理をまとめるような設計方法です。実はこれが最もオブジェクト指向実装の考え方に則しているといえます。オブジェクト指向においては論理モデル単位にクラス設計を行うため、それに最もマッチします。<br />
<br />
その他に考えられるのは、コントローラー単位にモデルクラスを定義するというものです。<br />
あまり好ましくない設計ということになるかもしれませんが、REST的な思想をモデルにまで持ち込み、どちらかと言うとコントローラー単位に付随するライブラリ的な位置づけになります。<br />
<br />
Curryではモデルに関して絶対的な規定はありません。<br />
しかし、推奨とするのはO/Rマッパー的な設計です。それを前提にした仕組みは用意されており、これに乗せることでデータアクセスが楽に行えるようになっています。<br />
しかしO/Rマッパーにはいくつか問題があるのも事実です。<br />
Curryではその一つをカバーする仕組みを取り入れていますが、それについては後述します。
</p>
				
	      <h3 id="7">O/Rマッパーの功罪とCurryでの位置付け</h3>
    		<p class="exp">
O/Rマッパーはモデルクラスをテーブルとして扱えるため、最終的なデータの格納場所であるテーブルとのデータのやり取りをプログラミング言語のレベルで記述できるというメリットがあります。これはSQL文を直接書かなくても良いということです。<br />
しかしその事は良し悪しで、裏で発行されているSQL文が見えないという問題点があります。SQLに精通した実装者であれば、発行するSQLを想像した上で、それを書く手間を省く、または記述ミスをなくすという程度のメリットとしてO/Rマッパーを利用するでしょう。<br />
しかし、SQLがあまり得意ではない実装者の場合は、クラスの仕組みに頼るという形になり、結果として得られるデータが正しければ問題を感じないため、実際に発行されているSQLが非効率的なものであったとしても問題を感じません。これが結果として世のWebアプリケーションの品質を下げる結果につながる懸念は捨て切れません。<br />
<br />
また、フレームワークの用意する仕組みでは複雑なSQLには対応できず、少し複雑な問い合わせが必要になると、SQL文を直接書かなければならないという結果になります。そうすると、そもそも複雑なSQLを書かなくてもいいようにテーブル側を設計するという考え方に結びつき、結果、正規化からかけ離れた非効率なテーブル設計を生み出す事になりかねません。必ずしもそうではないかもしれませんが、これもWebシステムの低質化につながる可能性を含んでいるのではないかと思います。<br />
<br />
Curryでは開発効率を考慮し、O/Rマッパーのような考え方を取り入れていますが、どちらかと言うとSQL生成の補助機能的なもので、最終的なSQL文を想像しながらそれをPHPのコーディングに落としていくような実装になるようになっています。<br />
また簡単な設定のみで、発行されるSQLがログとして出力されるようになっており、常にSQLを確認しながら開発を行うことができます。
</p>
				
	      <h3 id="6">4層アーキテクチャ</h3>
    		<p class="exp">
CurryはMVCを基本としていますが、MVCも万能ではありません。<br />
MVCで陥りやすい間違ったコーディングとして、コントローラーにメインロジックが入り込むということがよくあります。<br />
そもそもMVCの概念や正しい実装を理解していない場合は別として、システムによっては必然的にそうなってしまう場合があります。<br />
<br />
モデルはデータ操作を含めたロジックを担当するというのは前述のとおりです。<br />
Curryでも推奨しているようにモデルをテーブルオブジェクトとしての位置づけにした場合、モデル＝データという構図が出来てしまい、メインロジックの行き場がなくなります。そのロジックというのがテーブルより取得したデータを加工する意味合いのロジックであればモデルに含めてしまえばよいですが、データに一切かかわらない処理ロジックがある場合に困ります。そうするとロジックの行き場としてコントローラーという、MVCの本来の有るべき姿から逸脱してしまう事になってしまいがちです。<br />
<br />
また複数のテーブルの更新を一連の処理として整合を保つ「トランザクション」という考え方が存在しますが、一つ一つのモデルに対する処理をトランザクションとして統括するのはモデルより一層上となるはずです。しかしモデルクラスとテーブルを1：1とした場合、それを統括するロジックはどこに書くかという問題が出てきます。そうすると最もメインとなりそうなモデルを選んでその中に記述するのか、あるいはコントローラーで統括するのか、という妥協を含んだ判断になってきます。これはどちらも得策とは言えません。<br />
<br />
これらの事から、そもそもモデルとコントローラーという２層しかないことに無理がある事は否めません。そこで、モデルとコントローラーの中間に位置する層を置くことで対応するという事が考えられます。<br />
Curryではこれを「サービス」と呼び、その仕組みを組み込んでいます。<br />
前提として、モデルクラスはテーブルと結びつけます。その上でサービスはデータのトランザクション管理とロジックという2つの役割を持たせます。<br />
Curryではサービスもクラスで表現し、それを実現する仕組みを用意しています。<br />
本来のオブジェクト指向プログラミングにおけるモデリングはサービスという単位で設計し、モデルはデータという位置づけです。
</p>
				
	      <h3 id="8">RESTへの対応</h3>
    		<p class="exp">
RESTについての詳しい解説はここでは行いませんが、RESTにおいては「リソース」が重要なキーワードとなります。RESTで言うリソースとはWeb上に存在する個々の情報の事です。<br />
Webの利用者はブラウザにURIを入力し、情報を得ようとします。URIとはWeb上に散らばる無数の情報の中から特定の一つを指し示すものです。これは当たり前の事のようですが、RESTを理解する上で重要な事です。<br />
そしてHTTPにはリソースを操作するメソッドが存在します。全部でたった８つしかありません。<br />
中でも頻繁に使われるのはGETとPOSTですが、この２つについても本来のメソッドの正しい意味合い通りに使われていることはあまりありません。これらも含め、メソッドを正しく使おうというのがRESTです。中でもGET、POST、PUT、DELETEの４つです。<br />
<br />
リソースを一意に表現するのがURIですが、そのリソースに対して何を行うのかを示すのがメソッドの役割です。<br />
GETは現時点のリソースを取得します。<br />
POSTはリソースを追加します。<br />
PUTはリソースを更新、または追加します。<br />
DELETEはリソースを削除します。<br />
実情はこれらすべての操作はGETまたはPOSTですべて行われていることがほとんどですが、RESTfulなアプリケーションを構築する場合はそうではなく、メソッドを正しく使います。<br />
<br />
CurryにはRESTful実装を行うための簡易的な仕組みが存在します。<br />
HTMLの仕様上、フォームでPUTやDELETEは送信できません。そのためCurryでは擬似的にPUTやDELETEが使えるように設計しています。リソースを表現するアクションという単位を更に4つに分割し、同一アクションに対するリクエストをHTTPメソッドで切り分けることができます。<br />
<br />
通常はURIはコントローラーのアクションと1対1で結びつき、URIの指すパス指定の第2セグメントがアクションを表しますが、REST実装ではアクション名+HTTPメソッド名がアクソンメソッド名となり、例えばhogeアクションに対してPOSTメソッドでアクセスする場合は、hogePostというアクションメソッドが対応することになります。
</p>
				


  </div>

</div>
<div id="footer_frame">
Copyright(C) 2011 Curry PHP Framework developers. This software is released under the <a href="http://opensource.org/licenses/mit-license.php">MIT license</a>. 
</div>
</body>
</html>